
# 41343137

作業一

## 解題說明

多項式的建立與輸入
多項式的加法（Add）
多項式的乘法（Mult）
多項式的輸出（含正負號判斷）
多項式的代入運算（Eval）
採用「物件導向」方式設計，建立 Term 類別儲存單項式（係數與指數），再由 Polynomial 類別管理所有非零項。
多項式的運算（加法、乘法、代入）皆以項目為單位計算，並使用動態陣列 (new / delete[]) 來管理項數。
### 舉例

若
P1(x) = 2x² + 3x + 1
P2(x) = x² + 4

則
P1 + P2 = 3x² + 3x + 5
P1 × P2 = 2x⁴ + 3x³ + 9x² + 12x + 4
## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int Ak(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return Ak(m - 1, 1);
    else
        return Ak(m - 1, Ak(m, n - 1));
}

int main() {
    int m, n;
    cout << "Enter m and n: ";
    cin >> m >> n;

    cout << "A(" << m << "," << n << ") = " << Ak(m, n) << endl;

    return 0;
}

```

## 效能分析

1. 時間複雜度：成長極快，屬超多層遞迴$。
2. 空間複雜度：堆疊深度隨 m、n 增長劇烈$。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $m,n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $m=0,n=1$      | 2        | 2      |
| 測試二   | $m=1,n=2$      | 4        | 4       |
| 測試三   | $m=2,n=3$      | 9        | 9        |
| 測試四   | $m=3,n=2$      | 29       | 29       |

```
```

### 結論

1. 我深入理解了遞迴函式的運作原理。阿克曼函數雖然程式碼簡短，但遞迴深度極大，計算量呈超指數級成長
2. 學習到如何設計明確的「終止條件」以避免無限遞迴
   

## 申論及開發報告

### 選擇遞迴的原因
函數A(m,n) 的值取決於自身在不同參數下的結果，
若以遞迴實作，程式結構可直接對應公式，清楚且自然。
1. **程式結構簡潔、可讀性高**  
遞迴能以簡短的程式碼完成重複的層級運算，不需額外使用多層迴圈或複雜的控制變數，使程式更容易閱讀與維護

2. **遞迴的語意**  
遞迴的使用讓程式更直觀地對應問題的數學邏輯
透過實作過程，我體會到遞迴結構的威力與限制，也學習到如何設計終止條件以避免無限遞迴。
此外，觀察不同 m、n 值的結果變化，更加深了對遞迴層級與執行效率之間關係的理解。

3. **易於理解與實現**  
   阿克曼遞迴的程式碼能很好的直接用數學公式去推演 
   以本程式為例：  
 ```cpp
  int Ak(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return Ak(m - 1, 1);
    else
        return Ak(m - 1, Ak(m, n - 1));
}
   ```



















------------------------------------------------------------------------------------------------------------------------------------------------------------------


